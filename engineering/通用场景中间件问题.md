# 通用场景的中间件问题

## 消息队列

### 重复消费

消费者处理完消息，在提交offset前宕机，导致MQ重发消息。

解决方案：

1. 幂等性设计：每条消息对应唯一ID，在消费者端利用数据库或缓存记录消息ID，避免重复消费。
2. 数据库唯一索引：对关键业务字段加唯一索引。
3. 业务状态机/版本号：消费者端基于业务状态机进行状态判断。

### 消息丢失

- 生产者发送消息失败
- MQ接收到消息后，没持久化就宕机
- 消费者自动提交ACK，但是处理过程中出问题

解决方案：

1. 同步发送+重试 或 异步发送+失败回调
2. 将MQ消息保存机制改成同步刷盘，确保集群基本同步接收到消息后，再把确认结果发送给生产者
3. 手动提交ACK，即处理成功后再提交offset

### 消息顺序性

MQ一般配置下，不保证全局顺序

实现方式：

1. 单分区或单队列
2. 消费者端缓存消息并按序处理

### 消息积压

消费者消息处理能力不足

解决方法：

1. 扩容消费者
2. 临时降级：对于非关键消息，直接丢弃

## 缓存

### 缓存穿透

查询不存在的Key，每次都打到数据库。可能导致数据库流量激增

解决方案：

1. 引入布隆过滤器，拦截部分不存在的key（布隆过滤器是将所有存在的key预构建到bitmap中，所以会由于hash冲突把不存在的key判断为存在）
2. 对不存在的key缓存特殊值，设置较短的过期时间

### 缓存击穿

热点key过期时，大量针对热点key的请求同时打到DB

解决方案：

1. 对热点key采用永不过期策略
2. 分布式锁，双检加锁

### 缓存雪崩

大量key同时过期或缓存服务宕机，请求全部打到DB

解决方案：

1. 在固定过期时间基础上加随机值，避免集中过期
2. 多级缓存：本地缓存+分布式缓存，减低分布式缓存压力
3. 分布式缓存采用高可用架构

### 缓存数据一致性

1. CacheAside，先删缓存，再更新DB，查询时缓存未命中，则先查DB再回填到缓存
2. 延迟双删。先删缓存，再更新DB，延迟一段时间再删一次缓存
3. 基于binlog异步更新缓存

## 数据库

### 事务特性

#### 原子性

一个事务中的所有操作要么全部成功，要么全部失败，不会停留在中间状态。

由undo-log保证

事务修改数据前，先将原值写到undo-log，如果事务失败或手动执行回滚，就根据undo-log执行逆向操作，恢复数据到事务开始前的状态。

#### 一致性

事务执行前后，数据从一个合法状态转移到另一个合法状态，满足预定义的数据库约束。

由数据库约束机制和其他三个特性联合保证

#### 隔离性

多个事务并发执行时，彼此互不干扰，一个事务的中间状态对其他事务不可见。

由MVCC多版本并发控制和锁机制保证

1. MVCC多版本并发控制机制：实现非阻塞快照读，避免读操作加锁

    a. 每行数据都包含隐藏字段：最后修改当前行的事务ID、指向undo-log的指针，用于构建历史版本。
    b. 事务启动时，创建ReadView，决定哪些数据版本对当前事务可见。
    c. 普通select使用快照读，不阻塞写操作。

2. 锁机制

#### 持久性

一旦事务提交，其对数据库的修改操作就是永久的，即使数据库崩溃也不会丢失。

由redo-log保证。记录事务对数据页的物理修改，具有以下特性：

1. 顺序写，速度快
2. 先写日志再写数据：事务提交时先将修改写入redo-log-buffer，再持久化到磁盘redo-log，后台线程异步将脏页刷到数据文件。

### 锁

#### 按锁粒度

##### 行级锁

1. 记录锁：锁的是索引项，不是物理行
2. 间隙锁：锁定一个范围，但不包含记录本身，防止幻读
3. 临键锁：锁住记录和记录前的间隙。在范围查询时防止幻读
4. 插入意向锁：一种特殊的间隙锁。表示要在某个间隙插入一行记录，多个事务插入不同位置的时候，可以并发进行，提高并发性

##### 表级锁

元数据锁：在ddl执行时，会自动加上表元数据读锁，执行DML时会先获取表元数据读锁

#### 按锁的模式

1. 共享锁
2. 排他锁