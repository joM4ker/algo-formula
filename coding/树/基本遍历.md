# 基本遍历

## 前/中/后序

### 递归

```pseudocode
def orderTraversal(self, root: Optional[TreeNode]):
    def orderTraversal0(self, ptr: Optional[TreeNode]):
        if ptr is None:
            return
        前序处理节点
        preorderTraversal0(ptr.left, res)
        中序处理节点
        preorderTraversal0(ptr.right, res)
        后序处理节点

    orderTraversal0(root, res)
```

### 前/中序迭代

```pseudocode
def orderTraversal(self, root: Optional[TreeNode]):
    stack = []
    while root is not None or len(stack) > 0:
        while root is not None:
            前序处理节点
            stack.append(root)
            root = root.left
        root = stack.pop()
        中序处理节点
        root = root.right
        后序处理节点
    return res
```

### 后序迭代

```pseudocode
def orderTraversal(self, root: Optional[TreeNode]):
    stack = []
    prev = None
    while root is not None or len(stack) > 0:
        while root is not None:
            stack.append(root)
            root = root.left
        root = stack.pop()
        if not root.right or root.right == prev:    # 右节点为空 或 右节点已经被访问，此时可以处理当前节点
            后序处理节点
            prev = root     # 标记当前节点已经访问过，后续父节点还会被访问，此时判断右节点已经被访问过，就直接处理父节点了
            root = None     # 这会导致下次循环，弹出父节点
        else:               # 右节点不为空 且 还没有被访问
            stack.append(root)
            root = root.right
    return res
```

## 层序

```pseudocode
def level_order(root: Optional[TreeNode]):
    if not root:
        return
    queue = deque([root])
    while queue:
        node = queue.popleft()
        处理节点
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
```